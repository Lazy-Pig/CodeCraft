# CodeCraft
CodeCraft2019初赛题目

## 判题器（模拟器）
判题器写的没有poi大神写得好，主要的差异是我的有些死锁情况判不出来（不清楚原因...）

### 图形化界面（game模块）

图形化模块是基于pygame框架写的，主要是src中的game模块，图形化界面的具体特点：
- 只能显示某一个指定路口的详细路况，即每个tick每个车道上行驶的车辆的id号
- 固定显示每个road的3个车道（默认每个路口都是双向，正反各3个车道）
- 固定显示每个车道的10个槽位
- 这些限制只是为了方便图形化显示的限制，判题器的运行更新逻辑没有这样的限制的

![image](https://github.com/Lazy-Pig/CodeCraft/blob/master/%E5%88%A4%E9%A2%98%E5%99%A8%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%A4%BA%E4%BE%8B.gif)

### 判题器逻辑（abstracts模块）
- Car维护车辆要行驶的路径，实现车切换到下一个road
- Cross实现与路口相关的4个road的驶入/驶出更新（go_by_tick函数）
- Lane为车道抽象，将车道抽象为链表结构，每个节点就是一个车道槽位，抽象为LaneSlot，LaneSlot维护槽位的位置和该槽位的车辆;车辆驶入Lane时，创建一个槽位对象，链表尾部添加节点;车辆驶出Lane时，链表删除头节点;Lane每个tick只更新不会驶出车道的槽位，有可能驶出的车辆状态为waiting
- Road维护自己的双向（单向）车道，实现车辆进入Road时的Lane选择，以及路口更新时轮询每个Lane获取可能驶出的车辆

### 判题器单测（tests）
利用python的unittest模块写了6个单测，是大赛任务书中给的6个过路口的case

## 调度器
调度器分为路径规划和车辆出发调度两个部分，调度器初始化的时候会为每辆车进行路径规划，规划完成后路径固定不再更改。每个tick调度器只进行车辆出发调度。

### 路径规划（algrithms模块）
- 先将地图视为强连通图，利用Dijistra规划最短路径（road的权重就是length）
- 若有车的src到dest不存在最短路径，则利用广度优先搜索，从dest开始向前搜索，直至找到一个节点存在src到该节点的Dijistra最短路径为止，将Dijistra路径和广搜得到的路径拼接成src到dest的路径

### 车辆出发调度（schedulers模块）
- 调度器更新带动全局更新，首先更新所有的road，然后更新每个cross，死锁判断和处理（go_by_tick函数）
- Scheduler全景复现专用的调度器，按照规划好的answer.txt中的出发时间和路线，预演整个过程
- RevertScheduler的发车策略是：若当前tick地图上的行驶车辆超过一定的数量则不再发新车;当车辆路径中的所有road的饱和度都低于某个值时才能发这辆车。另外，当地图出现死锁则调整发车参数重新开始规划
